`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: NUS
// Engineer: Shahzor Ahmad, Rajesh C Panicker
// 
// Create Date: 27.09.2016 10:59:44
// Design Name: 
// Module Name: MCycle
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// Enhancement performed is to evaluate the signs of the operands and the magnitudes seperately, thereby 
// avoiding the need to perform twice the number of shifts for signed operations and saving on clock cycle.
//////////////////////////////////////////////////////////////////////////////////
/* 
----------------------------------------------------------------------------------
--	(c) Shahzor Ahmad, Rajesh C Panicker
--	License terms :
--	You are free to use this code as long as you
--		(i) DO NOT post it on any public repository;
--		(ii) use it only for educational purposes;
--		(iii) accept the responsibility to ensure that your implementation does not violate any intellectual property of ARM Holdings or other entities.
--		(iv) accept that the program is provided "as is" without warranty of any kind or assurance regarding its suitability for any particular purpose;
--		(v) send an email to rajesh.panicker@ieee.org briefly mentioning its use (except when used for the course CG3207 at the National University of Singapore);
--		(vi) retain this notice in this file or any files derived from this.
----------------------------------------------------------------------------------
*/

module MCycle

    #(parameter width = 4) // Keep this at 4 to verify your algorithms with 4 bit numbers (easier). When using MCycle as a component in ARM, generic map it to 32.
    (
        input CLK,
        input RESET, // Connect this to the reset of the ARM processor.
        input Start, // Multi-cycle Enable. The control unit should assert this when an instruction with a multi-cycle operation is detected.
        input [1:0] MCycleOp, // Multi-cycle Operation. "00" for signed multiplication, "01" for unsigned multiplication, "10" for signed division, "11" for unsigned division. Generated by Control unit
        input [width-1:0] _Operand1, // Multiplicand / Dividend
        input [width-1:0] _Operand2, // Multiplier / Divisor
        output reg [width-1:0] Result1, // LSW of Product / Quotient
        output reg [width-1:0] Result2, // MSW of Product / Remainder
        output reg Busy // Set immediately when Start is set. Cleared when the Results become ready. This bit can be used to stall the processor while multi-cycle operations are on.
    );
    
// use the Busy signal to reset WE_PC to 0 in ARM.v (aka "freeze" PC). The two signals are complements of each other
// since the IDLE_PROCESS is combinational, instantaneously asserts Busy once Start is asserted
  
    parameter IDLE = 1'b0 ;  // will cause a warning which is ok to ignore - [Synth 8-2507] parameter declaration becomes local in MCycle with formal parameter declaration list...

    parameter COMPUTING = 1'b1 ; // this line will also cause the above warning
    reg state = IDLE ;
    reg n_state = IDLE ;
    reg done ;
    reg [7:0] count = 0 ; // assuming no computation takes more than 256 cycles.
    reg [2*width-1:0] temp_sum = 0 ;
    reg [2*width-1:0] shifted_op1 = 0 ;
    reg [width-1:0] shifted_op1_mul = 0 ;
    reg [2*width-1:0] shifted_op2 = 0 ;     
//    reg [2*width-1:0] quotient = 0 ;     
    reg sign_op1 = 0;
    reg sign_op2 = 0;
    reg [2*width-1:0] temp_sum_signed = 0;
    reg signed_divide = 0;
    
    reg [width-1:0] Operand1;
    reg [width-1:0] Operand2; 
    
    always @ (*) begin
        if (MCycleOp[0] == 0) begin     // signed operation
            if (_Operand1[width - 1] == 1'b1) begin
                // If the MSB of _Operand1 is 1 (negative), apply two's complement by inverting and adding 1
                Operand1 = ~_Operand1 + 1'b1;
                
            end 
            else begin                  // unsigned operation 
                // If the MSB of _Operand1 is 0 (positive), keep Operand1 as it is
                Operand1 = _Operand1;
            end
            
            if (_Operand2[width - 1] == 1'b1) begin
                Operand2 = ~_Operand2 + 1'b1;        
            end 
            else begin 
                Operand2 = _Operand2;
            end 
            
        end else begin
            // If MCycleOp[0] is equal to 1 (indicating an unsigned operation), Operand1 remains unchanged
            Operand1 = _Operand1;
            Operand2 = _Operand2; 
            
        end
    end 
     
    always@( state, done, Start, RESET ) begin : IDLE_PROCESS  
		// Note : This block uses non-blocking assignments to get around an unpredictable Verilog simulation behaviour.
        // default outputs
        Busy <= 1'b0 ;
        n_state <= IDLE ;
        
        // reset
        if(~RESET)
            case(state)
                IDLE: begin
                    if(Start) begin // note: a mealy machine, since output depends on current state (IDLE) & input (Start)
                        n_state <= COMPUTING ;
                        Busy <= 1'b1 ;
                    end
                end
                COMPUTING: begin
                    if(~done) begin
                        n_state <= COMPUTING ;
                        Busy <= 1'b1 ;
                    end
                end        
            endcase    
    end


    always@( posedge CLK ) begin : STATE_UPDATE_PROCESS // state updating
        state <= n_state ;    
    end
    
    always@( posedge CLK ) begin : COMPUTING_PROCESS // process which does the actual computation
        // n_state == COMPUTING and state == IDLE implies we are just transitioning into COMPUTING
        if( RESET | (n_state == COMPUTING & state == IDLE) ) begin // 2nd condition is true during the very 1st clock cycle of the multiplication
            count = 0 ;
            temp_sum = 0 ;
            
                
            if (MCycleOp[1] == 0) begin // Multiply operation 
                shifted_op1 = {Operand1, {width{1'b0}}};        // Concatenate Operand1 with a sequence of 'width' zero bits
                shifted_op2 = { {width{1'b0}}, Operand2 };      
            end 
            else begin  // Division operation 
                shifted_op1 = {{width{1'b0}}, Operand1};        // Concatenate a sequence of 'width' zero bits with Operand1
                shifted_op2 = { Operand2, {width{1'b0}} } ; 
            end            
            
            // Used a seperate 32 bit register to demonstrate enhancement of multiplier.
            shifted_op1_mul = Operand1 ;  
        end 
        
        done <= 1'b0 ;   
        if( ~MCycleOp[1] ) begin // Multiply
   
            if( shifted_op2[0] == 1) // add only if b0 = 1
                shifted_op2[2*width-1:width] = shifted_op2[2*width-1:width] + shifted_op1_mul ; // partial product for multiplication
            
            shifted_op2 = {1'b0, shifted_op2[2*width-1 : 1]} ; // Shift op2 to right by one bit   
            
            if( count == width-1) 
                done <= 1'b1 ;   
                
            temp_sum = shifted_op2; 
            
            
            if (sign_op1 ^ sign_op2) begin // If sign_op1 XOR sign_op2 is true (one of them is 1), perform two's complement negation
                temp_sum_signed = ~temp_sum + 1'b1;
            end else begin
                // If sign_op1 and sign_op2 are both 0 or both 1 (same signs), no negation is needed
                temp_sum_signed = temp_sum;
            end
               
        end    
        
        else begin // Divide lynn 
            shifted_op1 = shifted_op1 + ~shifted_op2 + 1'b1;    // (dividend  - divisor)  --> (Remainder - divisor) 
            
            if (shifted_op1[2*width-1] == 1'b1) begin   // If result is negative, 
                shifted_op1 = shifted_op1 + shifted_op2;    // Restore to original remainder
                shifted_op1_mul = {shifted_op1_mul[width-2:0], 1'b0};  // Right shift quotient by 1 bit and set lsb as 0
            end
            else begin                                  // if remainder is positive,
                shifted_op1_mul = {shifted_op1_mul[width-2:0], 1'b1}; // Right shift quotient by 1 bit and set lsb as 1
            end
            
            shifted_op2 = {1'b0, shifted_op2[2*width-1 : 1]} ; // Shift op2 to right by one bit
            
            if (count == width )  // last cycle?
                done <= 1'b1 ;   
              
            temp_sum[2*width-1:width] = shifted_op1[width-1:0]; // remainder
            temp_sum[width-1:0] = shifted_op1_mul; //quotient
            
            
            if (sign_op1 ^ sign_op2) begin  
                temp_sum_signed[width-1:0] = ~temp_sum[width-1:0] + 1'b1;           // quotient calculation
                temp_sum_signed[2*width-1:width] =  ~temp_sum[2*width-1:width] + 1'b1;           // remainder calculation 
            end 
            else begin
                temp_sum_signed[width-1:0] = temp_sum[width-1:0];   // quotient calculation
                temp_sum_signed[2*width-1:width] = temp_sum[2*width-1:width] ;      // remainder calculation
            end 
            
        end  // lynn
        
        // Count variable moved out of each branch.
        count = count + 1; 
        
        // Extract sign bits from both operands
        sign_op1 = _Operand1[width - 1];
        sign_op2 = _Operand2[width - 1];
        
        if (~MCycleOp[0]) begin     // signed operation 
            Result1 = temp_sum_signed[width - 1 : 0]; //assign the LSB to Result1 from temp_sum_signed
            Result2 = temp_sum_signed[2 * width - 1 : width]; // assign the MSB to Result2 from temp_sum_signed
        end else begin              // unsigned operation 
            Result1 = temp_sum[width - 1 : 0];      // assign the LSB to Result1 from temp_sum          
            Result2 = temp_sum[2 * width - 1 : width];  // assign the MSB to Result2 from temp_sum
        end
     
    end
   
endmodule

















